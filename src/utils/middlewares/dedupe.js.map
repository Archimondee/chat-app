{"version":3,"file":"dedupe.js","sourceRoot":"","sources":["../../src/middlewares/dedupe.ts"],"names":[],"mappings":"AAkCA,cAAc;AAEd,MAAM,WAAW,GAAuB,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,CAAC,CACnD,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,CACzC,CAAA;AACD,MAAM,UAAU,GAAsB,CAAC,GAAW,EAAE,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,GAAG,GAAG,GAAG,GAAG,CAAA;AACpF,MAAM,eAAe,GAA2B,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAA;AAE5E,MAAM,CAAC,MAAM,MAAM,GAAqB,CAAC,EAAE,IAAI,GAAG,WAAW,EAAE,GAAG,GAAG,UAAU,EAAE,QAAQ,GAAG,eAAe,EAAE,GAAG,EAAE,EAAE,EAAE;IAEpH,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAA;IAE1B,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;QAE3B,IAAI,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE;YACnB,OAAO,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAA;SACvB;QAED,MAAM,IAAI,GAAG,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAA;QAE3B,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACvB,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,CAAA;SACvB;aAAM;YACL,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACrC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,CAAA;YAC5C,CAAC,CAAC,CAAA;SACH;QAED,IAAI;YACF,OAAO,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC;iBACnB,IAAI,CAAC,QAAQ,CAAC,EAAE;gBACf,2BAA2B;gBAC3B,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;gBACtE,uCAAuC;gBACvC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;gBACrB,+BAA+B;gBAC/B,OAAO,QAAQ,CAAA;YACjB,CAAC,CAAC;iBACD,KAAK,CAAC,KAAK,CAAC,EAAE;gBACb,mCAAmC;gBACnC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAA;gBAChE,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;gBACrB,MAAM,KAAK,CAAA;YACb,CAAC,CAAC,CAAA;SACL;QAAC,OAAO,KAAK,EAAE;YACd,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;YACrB,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;SAC7B;IAEH,CAAC,CAAA;AACH,CAAC,CAAA","sourcesContent":["import type { ConfiguredMiddleware, WretchOptions } from \"../types.js\"\n\n/* Types */\n\nexport type DedupeSkipFunction = (url: string, opts: WretchOptions) => boolean\nexport type DedupeKeyFunction = (url: string, opts: WretchOptions) => string\nexport type DedupeResolverFunction = (response: Response) => Response\nexport type DedupeOptions = {\n  skip?: DedupeSkipFunction,\n  key?: DedupeKeyFunction,\n  resolver?: DedupeResolverFunction\n}\n/**\n * ## Dedupe middleware\n *\n * #### Prevents having multiple identical requests on the fly at the same time.\n *\n * **Options**\n *\n * - *skip* `(url, opts) => boolean`\n *\n * > If skip returns true, then the dedupe check is skipped.\n *\n * - *key* `(url, opts) => string`\n *\n * > Returns a key that is used to identify the request.\n *\n * - *resolver* `(response: Response) => Response`\n *\n * > This function is called when resolving the fetch response from duplicate calls.\n * By default it clones the response to allow reading the body from multiple sources.\n */\nexport type DedupeMiddleware = (options?: DedupeOptions) => ConfiguredMiddleware\n\n/* Defaults */\n\nconst defaultSkip: DedupeSkipFunction = (_, opts) => (\n  opts.skipDedupe || opts.method !== \"GET\"\n)\nconst defaultKey: DedupeKeyFunction = (url: string, opts) => opts.method + \"@\" + url\nconst defaultResolver: DedupeResolverFunction = response => response.clone()\n\nexport const dedupe: DedupeMiddleware = ({ skip = defaultSkip, key = defaultKey, resolver = defaultResolver } = {}) => {\n\n  const inflight = new Map()\n\n  return next => (url, opts) => {\n\n    if (skip(url, opts)) {\n      return next(url, opts)\n    }\n\n    const _key = key(url, opts)\n\n    if (!inflight.has(_key)) {\n      inflight.set(_key, [])\n    } else {\n      return new Promise((resolve, reject) => {\n        inflight.get(_key).push([resolve, reject])\n      })\n    }\n\n    try {\n      return next(url, opts)\n        .then(response => {\n          // Resolve pending promises\n          inflight.get(_key).forEach(([resolve]) => resolve(resolver(response)))\n          // Remove the inflight pending promises\n          inflight.delete(_key)\n          // Return the original response\n          return response\n        })\n        .catch(error => {\n          // Reject pending promises on error\n          inflight.get(_key).forEach(([resolve, reject]) => reject(error))\n          inflight.delete(_key)\n          throw error\n        })\n    } catch (error) {\n      inflight.delete(_key)\n      return Promise.reject(error)\n    }\n\n  }\n}\n"]}