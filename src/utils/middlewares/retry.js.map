{"version":3,"file":"retry.js","sourceRoot":"","sources":["../../src/middlewares/retry.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ConfiguredMiddleware, WretchOptions } from \"../types.js\"\n\n/* Types */\n\nexport type DelayRampFunction = (delay: number, nbOfAttempts: number) => number\nexport type UntilFunction = (\n  response?: Response,\n  error?: Error\n) => boolean | Promise<boolean>\nexport type OnRetryFunctionResponse =\n  | { url?: string; options?: WretchOptions }\n  | undefined\nexport type OnRetryFunction = (args: {\n  response?: Response\n  error?: Error\n  url: string\n  options: WretchOptions\n}) => void | OnRetryFunctionResponse | Promise<OnRetryFunctionResponse>\nexport type SkipFunction = (url: string, opts: WretchOptions) => boolean\nexport type RetryOptions = {\n  /**\n   * The timer between each attempt in milliseconds.\n   *\n   * _Default: `500`_\n   */\n  delayTimer?: number\n  /**\n   * The custom function that is used to calculate the actual delay based on the the timer & the number of attemps.\n   *\n   * _Default: `delay * nbOfAttemps`_\n   */\n  delayRamp?: DelayRampFunction\n  /**\n   * The maximum number of retries before resolving the promise with the last error. Specifying 0 means infinite retries.\n   *\n   * _Default: `10`_\n   */\n  maxAttempts?: number\n  /**\n   * The request will be retried until that condition is satisfied.\n   *\n   * _Default: `response && response.ok`_\n   */\n  until?: UntilFunction\n  /**\n   * Callback that will get executed before retrying the request. If this function returns an object having url and/or options properties, they will override existing values in the retried request.\n   *\n   * _Default: `undefined`_\n   */\n  onRetry?: OnRetryFunction\n  /**\n   * If true, will retry the request if a network error was thrown. Will also provide an 'error' argument to the `onRetry` and `until` methods.\n   *\n   * _Default: `false`_\n   */\n  retryOnNetworkError?: boolean\n  /**\n   * If true, the request will be resolved with the latest response instead of rejected with an error.\n   *\n   * _Default: `false`_\n   */\n  resolveWithLatestResponse?: boolean\n  /**\n   * If skip returns true, the request will not be retried.\n   *\n   * Example:\n   * ```js\n   * (url, options) => (\n   *    options.method !== \"GET\"\n   * )\n   * ```\n   *\n   * _Default: `undefined`_\n   */\n  skip?: SkipFunction\n}\n\n/**\n * ## Retry middleware\n *\n * #### Retries a request multiple times in case of an error (or until a custom condition is true).\n *\n * > **ðŸ’¡ By default, the request will be retried if the response status is not in the 2xx range.**\n * >\n * > ```js\n * > // Replace the default condition with a custom one to avoid retrying on 4xx errors:\n * > until: (response, error) => response && (response.ok || (response.status >= 400 && response.status < 500))\n * > ```\n *\n * ```ts\n * import wretch from 'wretch'\n * import { retry } from 'wretch/middlewares'\n *\n * wretch().middlewares([\n *   retry({\n *     // Options - defaults below\n *     delayTimer: 500,\n *     delayRamp: (delay, nbOfAttempts) => delay * nbOfAttempts,\n *     maxAttempts: 10,\n *     until: (response, error) => response && response.ok,\n *     onRetry: null,\n *     retryOnNetworkError: false,\n *     resolveWithLatestResponse: false,\n *     skip: undefined\n *   })\n * ])\n *\n * // You can also return a Promise, which is useful if you want to inspect the body:\n * wretch().middlewares([\n *   retry({\n *     until: response =>\n *       response.clone().json().then(body =>\n *         body.field === 'something'\n *       )\n *   })\n * ])\n * ```\n */\nexport type RetryMiddleware = (options?: RetryOptions) => ConfiguredMiddleware\n\n/* Defaults */\n\nconst defaultDelayRamp: DelayRampFunction = (delay, nbOfAttempts) =>\n  delay * nbOfAttempts\nconst defaultUntil: UntilFunction = response => response && response.ok\n\nexport const retry: RetryMiddleware = ({\n  delayTimer = 500,\n  delayRamp = defaultDelayRamp,\n  maxAttempts = 10,\n  until = defaultUntil,\n  onRetry = null,\n  retryOnNetworkError = false,\n  resolveWithLatestResponse = false,\n  skip,\n} = {}) => {\n  return next => (url, opts) => {\n    let numberOfAttemptsMade = 0\n\n    if (skip && skip(url, opts)) {\n      return next(url, opts)\n    }\n\n    const checkStatus = (response?: Response, error?: Error) => {\n      return Promise.resolve(until(response, error)).then(done => {\n        // If the response is not suitable\n        if (!done) {\n          numberOfAttemptsMade++\n\n          if (!maxAttempts || numberOfAttemptsMade <= maxAttempts) {\n            // We need to recurse until we have a correct response and chain the checks\n            return new Promise(resolve => {\n              const delay = delayRamp(delayTimer, numberOfAttemptsMade)\n              setTimeout(() => {\n                if (typeof onRetry === \"function\") {\n                  Promise.resolve(\n                    onRetry({\n                      response,\n                      error,\n                      url,\n                      options: opts,\n                    })\n                  ).then((values = {}) => {\n                    resolve(\n                      next(\n                        (values && values.url) ?? url,\n                        (values && values.options) ?? opts\n                      )\n                    )\n                  })\n                } else {\n                  resolve(next(url, opts))\n                }\n              }, delay)\n            })\n              .then(checkStatus)\n              .catch(error => {\n                if (!retryOnNetworkError) throw error\n                return checkStatus(null, error)\n              })\n          } else {\n            return !!response && resolveWithLatestResponse\n              ? response\n              : Promise.reject(\n                error || new Error(\"Number of attempts exceeded.\")\n              )\n          }\n        }\n\n        return !!response && resolveWithLatestResponse\n          ? response\n          : error\n            ? Promise.reject(error)\n            : response\n      })\n    }\n\n    return next(url, opts)\n      .then(checkStatus)\n      .catch(error => {\n        if (!retryOnNetworkError) throw error\n        return checkStatus(null, error)\n      })\n  }\n}\n"]}