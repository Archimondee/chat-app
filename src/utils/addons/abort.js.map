{"version":3,"file":"abort.js","sourceRoot":"","sources":["../../src/addons/abort.ts"],"names":[],"mappings":"AA0EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCG;AACH,MAAM,KAAK,GAAkD,GAAG,EAAE;IAChE,OAAO;QACL,aAAa,CAAC,MAAM,EAAE,OAAO,EAAE,KAAK;YAClC,MAAM,eAAe,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,iBAAiB,EAAE,KAAK,EAAE,IAAI,CAAC,CAAA;YAC/E,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,eAAe,EAAE;gBACzC,OAAO,CAAC,QAAQ,CAAC,GAAG,eAAe,CAAC,MAAM,CAAA;aAC3C;YACD,MAAM,OAAO,GAAG;gBACd,GAAG,EAAE,IAAI;gBACT,KAAK;oBACH,IAAI,OAAO,CAAC,GAAG,EAAE;wBACf,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;wBACzB,OAAO,CAAC,GAAG,GAAG,IAAI,CAAA;qBACnB;gBACH,CAAC;aACF,CAAA;YACD,KAAK,CAAC,KAAK,GAAG;gBACZ,OAAO;gBACP,eAAe;aAChB,CAAA;YACD,OAAO,MAAM,CAAA;QACf,CAAC;QACD,MAAM,EAAE;YACN,MAAM,CAAC,UAAU;gBACf,OAAO,EAAE,GAAG,IAAI,EAAE,QAAQ,EAAE,EAAE,GAAG,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,MAAM,EAAE,EAAE,CAAA;YAC/E,CAAC;SACF;QACD,QAAQ,EAAE;YACR,UAAU,CAAC,IAAI,EAAE,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,eAAe;gBACnE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAA;gBAC3C,OAAO,CAAC,KAAK,EAAE,CAAA;gBACf,OAAO,CAAC,GAAG,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,KAAK,EAAE,EAAE,IAAI,CAAC,CAAA;gBACxD,OAAO,IAAI,CAAA;YACb,CAAC;YACD,UAAU,KAAK,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,eAAe,EAAE,IAAI,CAAC,CAAA,CAAC,CAAC;YACvE,OAAO,CAAC,EAAE,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,CAAC,CAAA,CAAC,CAAC;SACpD;KACF,CAAA;AACH,CAAC,CAAA;AAED,eAAe,KAAK,CAAA","sourcesContent":["import type { Wretch, WretchAddon, WretchErrorCallback, WretchResponseChain } from \"../types.js\"\n\nexport interface AbortWretch {\n  /**\n   * Associates a custom controller with the request.\n   *\n   * Useful when you need to use\n   * your own AbortController, otherwise wretch will create a new controller itself.\n   *\n   * ```js\n   * const controller = new AbortController()\n   *\n   * // Associates the same controller with multiple requests\n   * wretch(\"url1\")\n   *   .addon(AbortAddon())\n   *   .signal(controller)\n   *   .get()\n   *   .json()\n   * wretch(\"url2\")\n   *   .addon(AbortAddon())\n   *   .signal(controller)\n   *   .get()\n   *   .json()\n   *\n   * // Aborts both requests\n   * controller.abort()\n   * ```\n   *\n   * @param controller - An instance of AbortController\n   */\n  signal: <T extends AbortWretch, C, R>(this: T & Wretch<T, C, R>, controller: AbortController) => this\n}\n\nexport interface AbortResolver {\n  /**\n   * Aborts the request after a fixed time.\n   *\n   * If you use a custom AbortController associated with the request, pass it as the second argument.\n   *\n   * ```js\n   * // 1 second timeout\n   * wretch(\"...\").addon(AbortAddon()).get().setTimeout(1000).json(_ =>\n   *   // will not be called if the request timeouts\n   * )\n   * ```\n   *\n   * @param time - Time in milliseconds\n   * @param controller - An instance of AbortController\n   */\n  setTimeout: <T, C extends AbortResolver, R>(this: C & WretchResponseChain<T, C, R>, time: number, controller?: AbortController) => this\n  /**\n   * Returns the provided or generated AbortController plus the wretch response chain as a pair.\n   *\n   * ```js\n   * // We need the controller outside the chain\n   * const [c, w] = wretch(\"url\")\n   *   .addon(AbortAddon())\n   *   .get()\n   *   .controller()\n   *\n   * // Resume with the chain\n   * w.onAbort(_ => console.log(\"ouch\")).json()\n   *\n   * // Later onâ€¦\n   * c.abort()\n   * ```\n   */\n  controller: <T, C extends AbortResolver, R>(this: C & WretchResponseChain<T, C, R>) => [any, this]\n  /**\n   * Catches an AbortError and performs a callback.\n   */\n  onAbort: <T, C extends AbortResolver, R>(this: C & WretchResponseChain<T, C, R>, cb: WretchErrorCallback<T, C, R>) => this\n}\n\n/**\n * Adds the ability to abort requests using AbortController and signals under the hood.\n *\n *\n * _Only compatible with browsers that support\n * [AbortControllers](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).\n * Otherwise, you could use a (partial)\n * [polyfill](https://www.npmjs.com/package/abortcontroller-polyfill)._\n *\n * ```js\n * import AbortAddon from \"wretch/addons/abort\"\n *\n * const [c, w] = wretch(\"...\")\n *   .addon(AbortAddon())\n *   .get()\n *   .onAbort((_) => console.log(\"Aborted !\"))\n *   .controller();\n *\n * w.text((_) => console.log(\"should never be called\"));\n * c.abort();\n *\n * // Or :\n *\n * const controller = new AbortController();\n *\n * wretch(\"...\")\n *   .addon(AbortAddon())\n *   .signal(controller)\n *   .get()\n *   .onAbort((_) => console.log(\"Aborted !\"))\n *   .text((_) => console.log(\"should never be called\"));\n *\n * controller.abort();\n * ```\n */\nconst abort: () => WretchAddon<AbortWretch, AbortResolver> = () => {\n  return {\n    beforeRequest(wretch, options, state) {\n      const fetchController = wretch._config.polyfill(\"AbortController\", false, true)\n      if (!options[\"signal\"] && fetchController) {\n        options[\"signal\"] = fetchController.signal\n      }\n      const timeout = {\n        ref: null,\n        clear() {\n          if (timeout.ref) {\n            clearTimeout(timeout.ref)\n            timeout.ref = null\n          }\n        }\n      }\n      state.abort = {\n        timeout,\n        fetchController\n      }\n      return wretch\n    },\n    wretch: {\n      signal(controller) {\n        return { ...this, _options: { ...this._options, signal: controller.signal } }\n      },\n    },\n    resolver: {\n      setTimeout(time, controller = this._sharedState.abort.fetchController) {\n        const { timeout } = this._sharedState.abort\n        timeout.clear()\n        timeout.ref = setTimeout(() => controller.abort(), time)\n        return this\n      },\n      controller() { return [this._sharedState.abort.fetchController, this] },\n      onAbort(cb) { return this.error(\"AbortError\", cb) }\n    },\n  }\n}\n\nexport default abort\n"]}